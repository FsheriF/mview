#!/usr/bin/env perl

# Copyright (C) 1997-2018 Nigel P. Brown

###########################################################################
# Release information
###########################################################################
my $VERSION  = '1.62';
my $PATCH    = '1';
my $PROJECT  = 'MView';
my $AUTHOR   = "Nigel P. Brown";
my $VERSION  = $VERSION . ($PATCH?".$PATCH":"");
my $COPYYRS  = "1997-2018";
my $PROJPTH  = 'https://desmid.github.io/mview/';
my $AUTHMAIL = 'biomview@gmail.com';

###########################################################################
require 5.004;

$^W=1;
BEGIN {$::COMPILE_ERROR=0}  #catch compile time method call failure

use lib '/home/brown/HOME/work/MView/dev/lib';
use Bio::MView::Option::Parser;
use Bio::MView::Manager;
use strict;

exit 1  if $::COMPILE_ERROR;

###########################################################################
my $PROG    = Universal::basename($0);
my $SCRATCH = Universal::tmpfile("mview_$$");
my $INVOKE  = "$PROG @ARGV";

my $DOCTYPE = '<!DOCTYPE html>';
my $DOCMETA = '<META http-equiv="Content-Type" content="text/html; charset=utf-8"/>';

my ($HTML_NULL, $HTML_DATA, $HTML_CSS, $HTML_BODY, $HTML_HTML, $HTML_MIME) =
    (0,1,2,4,8,16);
my ($VERB_NULL, $VERB_FILE, $VERB_ARGV, $VERB_FORM, $VERB_OPTS) = (0,1,2,4,8);

###########################################################################
sub cleanup { unlink "$SCRATCH"  if -f "$SCRATCH" }

sub abort {
    foreach my $e (@_) {
        warn "$PROG: $e\n";
    }
    warn "$PROG: aborting\n";
    cleanup();
    exit 1;
}

$SIG{'INT'} = sub { abort("interrupted") };

###########################################################################
#parse default options and command line
my $stm = \*STDOUT;

my $com = new Bio::MView::Option::Parser($PROG);
my @err = $com->parse_argv(\@ARGV);

abort(@err)  if @err;

my $par = $com->get_parameters;

rationalise_parameters($par);

dump_parameters($par)  if $par->{'verbose'} & $VERB_OPTS;

#usage message and exit
if ($par->{'help'}) {
    print $stm usage($com, $par);
    exit 0;
}

#load user colormaps; before listcolors
if ($par->{'colorfile'} ne '') {
    local *TMP;
    open(TMP, "< $par->{'colorfile'}");
    Bio::MView::Manager::load_colormaps(\*TMP);
    close TMP;
}

#load user groupmaps; before listgroups
if ($par->{'groupfile'} ne '') {
    local *TMP;
    open(TMP, "< $par->{'groupfile'}");
    Bio::MView::Manager::load_groupmaps(\*TMP);
    close TMP;
}

#dump css and exit
if ($par->{'listcss'}) {
    print $stm dump_css();
    exit 0;
}

#dump colormaps and exit
if ($par->{'listcolors'}) {
    print $stm dump_colormaps($par);
    exit 0;
}

#dump groupmaps and exit
if ($par->{'listgroups'}) {
    print $stm dump_groupmaps($par);
    exit 0;
}

#html header
if ($par->{'html'}) {
    print $stm html_head($par);
}

#verbose mode: echo command line
if ($par->{'verbose'} & $VERB_ARGV) {
    print $stm command_line($com, $par);
}

#rdb mode: leading copyright
if ($par->{'mode'} eq 'rdb') {
    print $stm copyright($par);
}

#read from stdin?
unless (@ARGV or $par->{'noparse'}) {
    warn "$PROG: reading from standard input (Ctrl-C to cancel)\n";
    open(TMP, ">$SCRATCH") or
        abort("can't save to temporary file");
    while (<>) { print TMP }
    close TMP;
    push @ARGV, $SCRATCH;
}

#run mview and count alignments
my $count = mview($par, $stm, @ARGV);

if ($count) {
    #got something
    if ($par->{'html'} != $HTML_DATA and $par->{'mode'} =~ /^new/) {
        print $stm copyright($par);
    }
} else {
    my $s = "$PROG: no alignments found\n";
    print $s  if $par->{'html'} != $HTML_DATA;
    warn $s;
}

#html footer
if ($par->{'html'}) {
    print $stm html_foot($par);
}

#Universal::vmstat("FINISHED.");

cleanup();

exit 0;

###########################################################################
sub mview {
    my ($par, $stm) = (shift, shift);

    #Universal::vmstat("Manager constructor");

    my $mgr = new Bio::MView::Manager($PROG, %$par);

    foreach my $file (@_) {
        warn("$PROG: file '$file' does not exist\n"),  next  unless -e $file;
        warn("$PROG: file '$file' is not a file\n"),   next  unless -f $file;
        warn("$PROG: file '$file' is not readable\n"), next  unless -r $file;

        warn "$PROG: processing '$file'\n"  if $par->{'verbose'} & $VERB_FILE;

	#try to choose a format if one wasn't specified
        if (! $par->{'in'}) {
            my $format = Bio::MView::Manager::check_input_file($file);
            warn("$PROG: can't determine format\n"), next
                unless defined $format;
            warn "$PROG: format is probably '$format'\n"
                if $par->{'verbose'} & $VERB_FORM;
            $par->{'in'} = $format;
        }

	if (! defined $mgr->parse($file, $par->{'in'})) {
	    warn "$PROG: can't parse file '$file'\n";
	}
    }
    #Universal::vmstat("Manager constructor one");

    #colormap/groupmap listing request: no alignment
    return 0  if $par->{'noparse'};

    #save printing until end?
    if ($par->{'register'} and $par->{'mode'} eq 'new') {
	$mgr->print;
	#Universal::vmstat("print done (mview)");
    }
    return $mgr->alignment_count;
}

sub rationalise_parameters {
    my $par = shift;

    $par->{'html'} = 0  if $par->{'mode'} eq 'rdb';
    $par->{'html'} = 0  if $par->{'mode'} eq 'clustal';
    $par->{'html'} = 0  if $par->{'mode'} eq 'pir';
    $par->{'html'} = 0  if $par->{'mode'} eq 'msf';
    $par->{'html'} = 0  if $par->{'mode'} eq 'pearson';
    $par->{'html'} = 0  if $par->{'mode'} eq 'fasta';
    $par->{'html'} = 0  if $par->{'mode'} eq 'plain';

    if ($par->{'html'}) {
        #ignore style sheets if css is unset
        unless ($par->{'css1'}) {
            $par->{'html'} &= ($HTML_MIME|$HTML_HTML|$HTML_BODY|$HTML_DATA);
        }
    } else {
        #ignore style sheets
        $par->{'css1'} = 0;

        #ignore coloring if HTML is off!
        $par->{'aln_coloring'} = 'none';
        $par->{'con_coloring'} = 'none';
    }

    #switch off parsing if color/groupmap listing requested
    if ($par->{'listcolors'} or $par->{'listgroups'}) {
	$par->{'noparse'} = 1;
    } else {
	$par->{'noparse'} = 0;
    }
}

sub usage {
    my ($com, $par) = @_;
    $par->{'title'} = 'MView command line options';
    my $data = $com->usage();
    my $s = '';
    if ($par->{'html'}) {
        $s .= html_head($par);
        $s .= "<HR><PRE>\n$data</PRE><HR>\n";
        $s .= copyright($par);
        $s .= html_foot($par);
    } else {
        $s .= $data;
        $s .= copyright($par);
    }
    $s;
}

sub dump_css {
    #http://www.w3.org/TR/REC-CSS1#containment-in-html
    my $s = Bio::MView::Manager::dump_css(
	'alncolor' => $par->{'alncolor'}, 'labcolor' => $par->{'labcolor'},
	'symcolor' => $par->{'symcolor'}, 'gapcolor' => $par->{'gapcolor'},
	);
    $s;
}

sub dump_colormaps {
    my $par = shift;
    my $data = Bio::MView::Manager::dump_colormaps($par->{'html'});
    my $s = '';
    if ($par->{'html'}) {
        $s .= html_head($par);
        $s .= "<HR><PRE>\n$data</PRE><HR>\n";
        $s .= copyright($par);
        $s .= html_foot($par);
    } else {
        $s .= $data;
        $s .= copyright($par);
    }
    $s;
}

sub dump_groupmaps {
    my $par = shift;
    my $data = Bio::MView::Manager::dump_groupmaps($par->{'html'});
    my $s = '';
    if ($par->{'html'}) {
        $s .= html_head($par);
        $s .= "<HR><PRE>\n$data</PRE><HR>\n";
        $s .= copyright($par);
        $s .= html_foot($par);
    } else {
        $s .= $data;
        $s .= copyright($par);
    }
    $s;
}

sub command_line {
    my ($com, $par) = @_;
    my $data = $com->dump_argv;
    $data =~ s/\-+v[a-z]*[=\s]+\S+\s*//g;
    my $s = '';
    if ($par->{'html'}) {
	$s .= "<H4>command line:</H4>\n<CODE>";
	$s .= "$PROG $data";
	$s .= "</CODE>\n<H4>produced:</H4>\n";
    } else {
	$s .= "command line:\n";
	$s .= "$PROG $data\n";
	$s .= "produced:\n\n";
    }
    $s
}

sub copyright {
    my $par = shift;
    my $s = '';
    no strict;

    if ($par->{'mode'} eq 'rdb') {    #rdb files
        $s .= "# $PROJECT $VERSION, Copyright (C) $COPYYRS $AUTHOR\n";
	$s .= "# $INVOKE\n";
	return $s;
    }

    if ($par->{'html'}) {    #any HTML
        $s .= "<P><SMALL><A HREF=\"$PROJPTH\">$PROJECT</A> ";
        $s .= "$VERSION, Copyright \&copy; ";
        $s .= "$COPYYRS <A HREF=\"mailto:$AUTHMAIL\">$AUTHOR</A>";
        $s .= "</SMALL></P>\n";
	return $s;
    }

    if ($par->{'noparse'}) {    #listcolor/listgroups without HTML
        $s .= "# $PROJECT $VERSION, Copyright (C) $COPYYRS $AUTHOR\n";
	return $s;
    }

    $s = "\n$PROJECT $VERSION, Copyright (C) $COPYYRS $AUTHOR\n\n";
    $s;
}

sub html_head {
    my $par = shift;

    return ''  if $par->{'html'} == $HTML_DATA;

    my $s = '';

    #want MIME type?
    if ($par->{'html'} & $HTML_MIME) {
	$s .= "Content-Type: text/html\n\n";
    }

    #want HTML HEAD?
    if ($par->{'html'} & $HTML_HTML) {
        my $t = "$DOCMETA\n";

        #link styles
        if ($par->{'srs'}) {
            $t .= "<STYLE TYPE=\"text/css\">\n<!--\n";
            $t .= "A:link{background:transparent;color:$par->{'linkcolor'}}\n";
            $t .= "A:active{background:transparent;color:$par->{'alinkcolor'}}\n";
            $t .= "A:visited{background:transparent;color:$par->{'vlinkcolor'}}\n";
            $t .= "-->\n</STYLE>\n";
        }

	#want colour definitions?
	if ($par->{'html'} & $HTML_CSS) {
	    #alignment styles
	    if ($par->{'css1'} =~ /^(?:file|http):/i) {
		#link to style sheet
	        $t .= "<LINK REL=STYLESHEET HREF=\"$par->{'css1'}\">\n";
	    } else {
		#style sheet in situ
		$t .= "<STYLE TYPE=\"text/css\">\n<!--\n";
		$t .= Bio::MView::Manager::dump_css(
                    'alncolor' => $par->{'alncolor'},
                    'labcolor' => $par->{'labcolor'},
                    'symcolor' => $par->{'symcolor'},
                    'gapcolor' => $par->{'gapcolor'},
		);
		$t .= "-->\n</STYLE>\n";
	    }
	}

        #page TITLE
        if (defined $par->{'title'} and $par->{'title'} ne "") {
            $t .= "<TITLE>$par->{'title'}</TITLE>\n";
        } else {
            $t .= "<TITLE>MView</TITLE>\n";
        }

        $s .= "$DOCTYPE\n<HTML>\n";
        $s .= "<HEAD>\n$t</HEAD>\n"  if $t;
    }

    #want BODY?
    if ($par->{'html'} & $HTML_BODY) {
        $s .= "<BODY style=\"background-color:$par->{'pagecolor'}; color:$par->{'textcolor'}\">\n";
    }

    #want TITLE? (in document)
    if (defined $par->{'title'} and $par->{'title'} ne "") {
	$s .= "<H4>$par->{'title'}</H4>\n";
    }

    $s;
}

sub html_foot {
    my $par = shift;
    return ''  if $par->{'html'} == $HTML_DATA;
    my $s = '';
    $s .= "</BODY>\n"  if $par->{'html'} & $HTML_BODY;
    $s .= "</HTML>\n"  if $par->{'html'} & $HTML_HTML;
    $s;
}

sub dump_parameters {
    my $par = shift;
    warn "\nProcessed parameters:\n";
    foreach my $k (sort keys %$par) {
        my $v = 'undef';
        $v = $par->{$k}  if defined $par->{$k};
        $v = "[" . join(",", @$v) . "]"  if ref $v eq 'ARRAY';
        warn sprintf("%-20s => %s\n", $k, $v);
    }
    warn "\n";
}


###########################################################################
