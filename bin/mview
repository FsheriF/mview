#!/usr/bin/env perl

# Copyright (C) 1997-2018 Nigel P. Brown

###########################################################################
# Release information
###########################################################################
my $VERSION  = '1.62';
my $PATCH    = '1';
my $PROJECT  = 'MView';
my $AUTHOR   = "Nigel P. Brown";
my $VERSION  = $VERSION . ($PATCH?".$PATCH":"");
my $COPYYRS  = "1997-2018";
my $PROJPTH  = 'https://desmid.github.io/mview/';
my $AUTHMAIL = 'biomview@gmail.com';

###########################################################################
require 5.004;

$^W=1;
BEGIN {$::COMPILE_ERROR=0}  #catch compile time method call failure

use lib '/home/brown/HOME/work/MView/dev/lib';
use Bio::Getopt;
use Bio::MView::Manager;
use strict;

exit 1  if $::COMPILE_ERROR;

###########################################################################
my $PROG    = Universal::basename($0);
my $SCRATCH = Universal::tmpfile("mview_$$");
my $INVOKE  = "$PROG @ARGV";

my $DOCTYPE = '<!DOCTYPE html>';
my $DOCMETA = '<META http-equiv="Content-Type" content="text/html; charset=utf-8"/>';

my %KNOWN_FORMAT =
    (
     #search formats
     'blast'    => 1,
     'uvfasta'  => 1,

     #flatfile formats
     'plain'   	=> 1,
     'clustal' 	=> 1,
     'msf'     	=> 1,
     'fasta'   	=> 1,
     'pir'     	=> 1,
     'hssp'    	=> 1,
     'maf'     	=> 1,
     'multas'  	=> 1,
     'mips'    	=> 1,
     'jnetz'   	=> 1,
    );

my ($HTML_NULL, $HTML_DATA, $HTML_CSS, $HTML_BODY, $HTML_HTML, $HTML_MIME) =
    (0,1,2,4,8,16);
my ($VERB_NULL, $VERB_FILE, $VERB_ARGV, $VERB_FORM, $VERB_OPTS) = (0,1,2,4,8);
my ($stm, $com, $opt, $par) = (\*STDOUT);

###########################################################################
$SIG{'INT'} =
    sub { warn "$PROG: interrupted - aborting.\n"; &cleanup(); exit 1 };

$com = new Bio::Getopt($PROG, \*DATA);
$com->parse_options(\@ARGV);
$opt = $com->get_option_hash;
$par = $com->get_parameter_hash;
rationalise_parameters($opt, $par);
dump_options($com)  if $opt->{'verbose'} & $VERB_OPTS;
usage($com, $opt, $par, 0)  if $opt->{'help'};

#CSS listing request: no alignment, no HTML
if ($opt->{'listcss'}) {
    #http://www.w3.org/TR/REC-CSS1#containment-in-html
    print $stm Bio::MView::Manager::list_css(
	'alncolor' => $par->{'alncolor'},
	'labcolor' => $par->{'labcolor'},
	'symcolor' => $par->{'symcolor'},
	'gapcolor' => $par->{'gapcolor'},
	);
    exit 0;
}

html_head($opt, $par, $stm);

#echo command line?
if ($opt->{'verbose'} & $VERB_ARGV) {
    my $s = $com->dump_argv;
    $s =~ s/\-+v[a-z]*[=\s]+\S+\s*//g;
    if ($opt->{'html'}) {
	print $stm "<H4>command line:</H4>\n<CODE>";
	print $stm "$PROG $s";
	print $stm "</CODE>\n<H4>produced:</H4>\n";
    } else {
	print $stm "command line:\n";
	print $stm "$PROG $s\n";
	print $stm "produced:\n\n";
    }
}

#leading copyright?
print $stm copyright($opt)    if $opt->{'out'} eq 'rdb';

#colormap listing request: no alignment
if ($opt->{'listcolors'}) {
    print $stm "<HR><PRE>\n"       if $opt->{'html'};
    print $stm Bio::MView::Manager::list_colormaps($opt->{'html'});
    print $stm "</PRE><HR>\n"      if $opt->{'html'};
    print $stm copyright($opt);
    html_foot($opt, $par, $stm);
    exit 0;
}

#groupmap listing request: no alignment
if ($opt->{'listgroups'}) {
    print $stm "<HR><PRE>\n"       if $opt->{'html'};
    print $stm Bio::MView::Manager::list_groupmaps($opt->{'html'});
    print $stm "</PRE><HR>\n"      if $opt->{'html'};
    print $stm copyright($opt);
    html_foot($opt, $par, $stm);
    exit 0;
}

#read from stdin?
unless (@ARGV or $opt->{'noparse'}) {
    warn "$PROG: reading from standard input (Ctrl-C to cancel)\n";
    open(TMP, ">$SCRATCH") or
        die "$PROG: can't save to temporary file - aborting.\n";
    while (<>) { print TMP }
    close TMP;
    push @ARGV, $SCRATCH;
}

#do the real work
if (mview($opt, $par, $stm, @ARGV)) {
    print $stm copyright($opt)  if $opt->{'html'} != $HTML_DATA and
        $opt->{'out'} =~ /^new/;
} else {
    my $s = "$PROG: no alignments found\n";
    print $s  if $opt->{'html'} and $opt->{'html'} != $HTML_DATA;
    warn $s;
}
html_foot($opt, $par, $stm);

#Universal::vmstat("FINISHED.");

cleanup();


###########################################################################
sub mview {
    my ($opt, $par, $stm) = (shift, shift, shift);
    my ($mgr, $file, $format);

    #Universal::vmstat("Manager constructor");

    $mgr = new Bio::MView::Manager($PROG, %$par);

    foreach $file (@_) {
	unless (-e $file) {
	    warn "$PROG: '$file' does not exist\n";
	    next;
	}
	unless (-f $file) {
	    warn "$PROG: '$file' is not a file\n";
	    next;
	}
	unless (-r $file) {
	    warn "$PROG: '$file' is not readable\n";
	    next;
	}
        warn "$PROG: processing '$file'\n"  if $opt->{'verbose'} & $VERB_FILE;

	#try to choose a format if one wasn't specified
	$format = (defined $opt->{'in'} ? $opt->{'in'} :
		   check_format($file, 'file'));
        warn "$PROG: format is probably '$format'\n"
	    if !defined $opt->{'in'} and $opt->{'verbose'} & $VERB_FORM;
	
	print $stm "<PRE>\n"    if $opt->{'pre'};

	if (! defined $mgr->parse($file, $format)) {
	    warn "$PROG: can't parse file '$file'\n";
	}

	print $stm "</PRE>\n"   if $opt->{'pre'};
    }
    #Universal::vmstat("Manager constructor done");

    #colormap/groupmap listing request: no alignment
    return 0  if $par->{'noparse'};

    #save printing until end?
    if ($par->{'register'} and $opt->{'out'} eq 'new') {
	$mgr->print;
	#Universal::vmstat("print done (mview)");
    }
    return $mgr->alignment_count;
}

sub cleanup { unlink "$SCRATCH"    if -f "$SCRATCH" }

sub rationalise_parameters {
    my ($o, $p) = @_;

    #ignore HTML if RDB output
    ($o->{'html'}, $p->{'html'}) = (0, 0)  if $p->{'mode'} eq 'rdb';

    #ignore HTML if CLUSTAL output
    ($o->{'html'}, $p->{'html'}) = (0, 0)  if $p->{'mode'} eq 'clustal';

    #ignore HTML if PIR output
    ($o->{'html'}, $p->{'html'}) = (0, 0)  if $p->{'mode'} eq 'pir';

    #ignore HTML if MSF output
    ($o->{'html'}, $p->{'html'}) = (0, 0)  if $p->{'mode'} eq 'msf';

    #ignore HTML if pearson/fasta output
    ($o->{'html'}, $p->{'html'}) = (0, 0)  if $p->{'mode'} eq 'pearson';
    ($o->{'html'}, $p->{'html'}) = (0, 0)  if $p->{'mode'} eq 'fasta';

    #ignore HTML if plain output
    ($o->{'html'}, $p->{'html'}) = (0, 0)  if $p->{'mode'} eq 'plain';

    #switch off preformatted flag if HTML is off
    $o->{'pre'} = 0  unless $o->{'html'};

    #ignore style sheets if HTML off
    ($o->{'css'}, $p->{'css1'}) = ('off', 0)  if $o->{'html'} == 0;

    #ignore style sheets in HTML if css is unset
    $o->{'html'} &= ($HTML_MIME|$HTML_HTML|$HTML_BODY|$HTML_DATA)
    	if $o->{'css'} eq 'off';

    #ignore coloring if HTML is off!
    unless ($o->{'html'}) {
	$p->{'aln_coloring'} = 'none';
	$p->{'con_coloring'} = 'none';
    }

    #switch off parsing if color/groupmap listing requested
    if ($o->{'listcolors'} or $o->{'listgroups'}) {
	$o->{'noparse'} = $p->{'noparse'} = 1;
	$o->{'pre'} = 0;
    } else {
	$o->{'noparse'} = $p->{'noparse'} = 0;
    }
}

sub html_head {
    my ($o, $p, $stm) = (@_, *STDOUT);

    #warn "HTML=$o->{'html'}\n";

    return    unless $o->{'html'};
    return    if $o->{'html'} == $HTML_DATA;

    #want MIME type?
    if ($o->{'html'} & $HTML_MIME) {
	print $stm "Content-Type: text/html\n\n";
    }

    #want HTML HEAD?
    if ($o->{'html'} & $HTML_HTML) {
        my $s = "$DOCMETA\n";

        #link styles
        if ($o->{'srs'} eq 'on') {
            $s .= "<STYLE TYPE=\"text/css\">\n<!--\n";
            $s .= "A:link{background:transparent;color:$o->{'linkcolor'}}\n";
            $s .= "A:active{background:transparent;color:$o->{'alinkcolor'}}\n";
            $s .= "A:visited{background:transparent;color:$o->{'vlinkcolor'}}\n";
            $s .= "-->\n</STYLE>\n";
        }

	#want colour definitions?
	if ($o->{'html'} & $HTML_CSS) {
	    #alignment styles
	    if ($o->{'css'} =~ /^(?:file|http):/i) {
		#link to style sheet
	        $s .= "<LINK REL=STYLESHEET HREF=\"$o->{'css'}\">\n";
	    } else {
		#style sheet in situ
		$s .= "<STYLE TYPE=\"text/css\">\n<!--\n";
		$s .= Bio::MView::Align::list_css1_colormaps
		    ('alncolor' => $p->{'alncolor'},
		     'labcolor' => $p->{'labcolor'},
		     'symcolor' => $p->{'symcolor'},
		     'gapcolor' => $p->{'gapcolor'},
		    );
		$s .= "-->\n</STYLE>\n";
	    }
	}

        #page TITLE
        if (defined $o->{'title'} and $o->{'title'} ne "") {
            $s .= "<TITLE>$o->{'title'}</TITLE>\n";
        } else {
            $s .= "<TITLE>MView</TITLE>\n";
        }

        print $stm "$DOCTYPE\n<HTML>\n";
        print $stm "<HEAD>\n$s</HEAD>\n"  if $s;
    }

    #want BODY?
    if ($o->{'html'} & $HTML_BODY) {
        print $stm "<BODY style=\"background-color:$o->{'pagecolor'}; color:$o->{'textcolor'}\">\n";
    }

    #want TITLE? (in document)
    if (defined $o->{'title'} and $o->{'title'} ne "") {
	print $stm "<H4>$o->{'title'}</H4>\n";
    }
}

sub html_foot {
    my ($o, $p, $stm) = (@_, *STDOUT);
    return    unless $o->{'html'};
    return    if $o->{'html'} == $HTML_DATA;
    print $stm "</BODY>\n"    if $o->{'html'} & $HTML_BODY;
    print $stm "</HTML>\n"    if $o->{'html'} & $HTML_HTML;
}

sub check_format {

    sub FASTA {
	return 'Pearson'  unless $_[1] eq 'file';
	local $_, *TMP;
	my $guess = 'Pearson';
	open(TMP, "< $_[0]") or die "$PROG: can't open '$_[0]'\n";
	while (<TMP>) {
	    next  if /^\s*$/;
	    $guess = 'FASTA'  unless /^\s*>/;
	    last;
	}
	close TMP;
	return $guess;
    }

    return map { lc $_ } sort keys %KNOWN_FORMAT  unless @_;

    my ($base, $ext) = ($_[0], '');
    ($base, $ext) = Universal::fileparts($_[0])  if $_[1] eq 'file';
    #warn "($base, $ext)";

    #switch: extension starts with:
    foreach ($ext) {
	return 'CLUSTAL'  if $_ =~ /^aln/i;
	return 'CLUSTAL'  if $_ =~ /^clu/i;
	return 'HSSP'     if $_ =~ /^hss/i;
	return 'JNETZ'    if $_ =~ /^jnt/i;
	return 'JNETZ'    if $_ =~ /^jne/i;
	return 'MAF'      if $_ =~ /^maf/i;
	return 'MIPS'     if $_ =~ /^mip/i;
	return 'MSF'      if $_ =~ /^msf/i;
	return 'MULTAS'   if $_ =~ /^mul/i;
	return 'PIR'      if $_ =~ /^pir/i;
	return 'Plain'    if $_ =~ /^txt/i;
	return 'Plain'    if $_ =~ /^pla/i;
	return 'Plain'    if $_ =~ /^pln/i;
	return 'BLAST'    if $_ =~ /^bla/i;
	return 'BLAST'    if $_ =~ /^tbl/i;
	return 'BLAST'    if $_ =~ /^phi/i;
	return 'BLAST'    if $_ =~ /^psi/i;
	return 'FASTA'    if $_ =~ /^tfa/i;
	return 'FASTA'    if $_ =~ /^ggs/i;
	return 'FASTA'    if $_ =~ /^gls/i;
	return 'FASTA'    if $_ =~ /^ss/i;
	return FASTA(@_)  if $_ =~ /^fa/i;
    }
    #fall through, switch: basename contains:
    foreach ($base) {
        return 'CLUSTAL'  if $_ =~ /aln/i;
        return 'CLUSTAL'  if $_ =~ /clu/i;
        return 'HSSP'     if $_ =~ /hssp/i;
        return 'JNETZ'    if $_ =~ /jnet/i;
        return 'MAF'      if $_ =~ /maf/i;
        return 'MIPS'     if $_ =~ /mips/i;
        return 'MSF'      if $_ =~ /msf/i;
        return 'MULTAS'   if $_ =~ /multal/i;
        return 'MULTAS'   if $_ =~ /multas/i;
        return 'PIR'      if $_ =~ /pir/i;
        return 'Plain'    if $_ =~ /plain/i;
        return 'BLAST'    if $_ =~ /blast/i;
        return 'BLAST'    if $_ =~ /tblast/i;
        return 'BLAST'    if $_ =~ /phi.*blast/i;
        return 'BLAST'    if $_ =~ /psi.*blast/i;
        return 'FASTA'    if $_ =~ /ggsearch/i;
        return 'FASTA'    if $_ =~ /glsearch/i;
        return 'FASTA'    if $_ =~ /ssearch/i;
        return 'FASTA'    if $_ =~ /uvf/i;
        return 'FASTA'    if $_ =~ /tfast/i;
        return 'FASTA'    if $_ =~ /fast[fmsxy]/i;
	return FASTA(@_)  if $_ =~ /fa/i;
        return 'Pearson'  if $_ =~ /pear/i;
    }
    #fall through, unknown format
    warn "$PROG: can't determine format - aborting\n";
    cleanup();
    exit 1;
}

sub usage {
    my ($com, $opt, $par, $exit, $stm) = (@_, *STDOUT);
    $opt->{'title'} = 'MView command line options';
    html_head($opt, $par, $stm);
    print $stm "<HR><PRE>\n"       if $opt->{'html'};
    print $stm $com->usage($stm);
    print $stm "</PRE><HR>\n"      if $opt->{'html'};
    print $stm copyright($opt);
    html_foot($opt, $par, $stm);
    exit $exit    if defined $exit;
}

sub dump_options {
    my $com = shift;
    warn "Input options:\n"       . $com->dump_options();
    warn "\nPassed parameters:\n" . $com->dump_parameters();
    warn "\n";
}

sub copyright {
    my ($opt) = @_;
    my $s = '';
    no strict;

    if ($opt->{'out'} eq 'rdb') {    #rdb files
        $s .= "# $PROJECT $VERSION, Copyright (C) $COPYYRS $AUTHOR\n";
	$s .= "# $INVOKE\n";
	return $s;
    }

    if ($opt->{'html'}) {    #any HTML
        $s .= "<P><SMALL><A HREF=\"$PROJPTH\">$PROJECT</A> ";
        $s .= "$VERSION, Copyright \&copy; ";
        $s .= "$COPYYRS <A HREF=\"mailto:$AUTHMAIL\">$AUTHOR</A>";
        $s .= "</SMALL></P>\n";
	return $s;
    }

    if ($opt->{'noparse'}) {    #listcolor/listgroups without HTML
        $s .= "# $PROJECT $VERSION, Copyright (C) $COPYYRS $AUTHOR\n";
	return $s;
    }

    $s = "\n$PROJECT $VERSION, Copyright (C) $COPYYRS $AUTHOR\n\n";
    $s;
}


###########################################################################
__DATA__

text:     "usage: <PROG> [options] [file...]\n\n
Option names and parameter values can generally be abbreviated. Alternative\n
parameter values are listed in braces {}, followed by the default value in\n
square brackets [].\n\n
Some options take multiple arguments which must be supplied as a comma\n
separated list, like '1,8,9,10'. Subranges are allowed, so you could also\n
write that as '1,8:10' or even '1,8..10'. Any argument must be quoted if it\n
contains whitespace or a wildcard that might be expanded by the shell\n"


###########################################################################
#silent options because no 'usage:' field.
[SILENT]

#force @ARGV to be examined for '-help' first.
OPTION:   help
default:  0
action:   sub { <ARGS>; <OPTION>{<ONAME>} = 1    if <OVAL> }

#force @ARGV to be examined for '-listcolors' first.
OPTION:   listcolors
default:  0
action:   sub { <ARGS>; <OPTION>{<ONAME>} = 1    if <OVAL> }

#force @ARGV to be examined for '-listgroups' first.
OPTION:   listgroups
default:  0
action:   sub { <ARGS>; <OPTION>{<ONAME>} = 1    if <OVAL> }

#force @ARGV to be examined for '-listcss' first.
OPTION:   listcss
default:  0
action:   sub { <ARGS>; <OPTION>{<ONAME>} = 1    if <OVAL> }

#force @ARGV to be examined for '-colorfile' first.
OPTION:   colorfile
type:     s
action:   sub { <ARGS>;
              local *TMP;
              if (defined <OVAL>) {
                  open(TMP, "< <OVAL>") or CORE::die "<PROG>: can't open colormap file '<OVAL>'\n";
                  Bio::MView::Manager::load_colormaps(\*TMP);
                  close TMP;
              }
          }

#force @ARGV to be examined for '-groupfile' first.
OPTION:   groupfile
type:     s
action:   sub { <ARGS>;
              local *TMP;
              if (defined <OVAL>) {
                  open(TMP, "< <OVAL>") or CORE::die "<PROG>: can't open consensus group file '<OVAL>'\n";
                  Bio::MView::Manager::load_groupmaps(\*TMP);
                  close TMP;
              }
          }

#set the default colormaps and groupmaps (assume protein)
OPTION:   aa
action:   sub { <ARGS>;
                (<PARAM>{'def_aln_colormap'},
                 <PARAM>{'def_con_colormap'}) =
                   Bio::MView::Manager::get_default_colormaps('aa');
                <PARAM>{'def_aln_groupmap'} = <PARAM>{'def_con_groupmap'} =
                  Bio::MView::Manager::get_default_groupmap('aa');
                <PARAM>{'moltype'} = 'aa';
                return 0;
          }

#verbosity level, normally 0 to keep quiet
OPTION:   verbose
type:     i
default:  0

#obsolete options: report fact to user
OPTION:   dna
action:   sub { <ARGS>; <WARN>("obsolete option '-<ONAME>' replaced by '-moltype dna'") if defined <OVAL>; }

OPTION:   keep
action:   sub { <ARGS>; <WARN>("obsolete option '-<ONAME>' renamed as '-show'") if defined <OVAL>; }

OPTION:   disc
action:   sub { <ARGS>; <WARN>("obsolete option '-<ONAME>' renamed as '-hide'") if defined <OVAL>; }

###########################################################################
[FORMATS]

text:     "Input/output formats:"

OPTION:   in
usage:    "Input <CHOOSE>(main::check_format)"
type:     s
action:   sub { <ARGS>;
                return <OPTION>{<ONAME>} = main::check_format(<OVAL>, 'par')
                    if defined <OVAL>;
                return undef;
          }

OPTION:   out
usage:    "Output <CHOOSE>(Bio::MView::Manager::check_convert_mode)"
type:     s
default:  new
param:    mode
convert:  sub { <ARGS>;
                <OPTION>{'pre'} = 1;
                if    (<OVAL> =~ /^n/i)  { <PVAL> = 'new'; <OPTION>{'pre'} = 0; }
                elsif (<OVAL> =~ /^pl/i) { <PVAL> = 'plain'; }
                elsif (<OVAL> =~ /^fa/i) { <PVAL> = 'pearson'; }
                elsif (<OVAL> =~ /^pe/i) { <PVAL> = 'pearson'; }
                elsif (<OVAL> =~ /^pi/i) { <PVAL> = 'pir'; }
                elsif (<OVAL> =~ /^ms/i) { <PVAL> = 'msf'; }
                elsif (<OVAL> =~ /^cl/i) { <PVAL> = 'clustal'; }
                elsif (<OVAL> =~ /^al/i) { <PVAL> = 'clustal'; }
                elsif (<OVAL> =~ /^rd/i) { <PVAL> = 'rdb'; <OPTION>{'pre'} = 0; }
                else {
                    <WARN>("bad option '-<ONAME>=<OVAL>'");
                    <WARN>("known types are: ", join(",",
                      Bio::MView::Manager::check_convert_mode));
                }
                <PVAL>;
          }

###########################################################################
[CONTENT]

text:     "Main formatting options:"

OPTION:   ruler
usage:    "Show ruler"
type:     b
default:  on
param:

OPTION:   alignment
usage:    "Show alignment"
type:     b
default:  on
param:

OPTION:   conservation
usage:    "Show clustal conservation line"
type:     b
default:  off
param:

OPTION:   consensus
usage:    "Show consensus"
type:     b
default:  off
param:

OPTION:   width
usage:    "Paginate alignment in blocks of N columns {N,flat}"
type:     s
default:  flat
param:
convert:  sub { <ARGS>;
            if (<OVAL> eq 'flat') { return 0; }
            else                  { return <TEST>('i', <ONAME>, <OVAL>); }
          }

###########################################################################
[IDENTITY]

text: "Percent identity calculations and filters:"

OPTION:   pcid
usage:    "Compute percent identities with respect to <CHOOSE>(Bio::MView::Manager::check_identity_mode)"
type:     s
default:  'aligned'
param:
convert:  sub { <ARGS>;
                return 'reference' if <OVAL> =~ /^r/;
                return 'aligned'   if <OVAL> =~ /^a/;
                return 'hit'       if <OVAL> =~ /^h/;
                <WARN>("bad option '-<ONAME>=<OVAL>'");
                <WARN>("known percent identity methods are: ", join(",",
                Bio::MView::Manager::check_identity_mode));
              }

OPTION:   reference
usage:    "Use row N or row identifier as %identity reference"
type:     s
default:  query
param:    ref_id

OPTION:   minident
usage:    "Only report sequences with percent identity >= N compared to reference"
type:     f
default:  0
param:
convert:  sub { <ARGS>;
                if (<OVAL> < 0 or <OVAL> > 100) {
                    <WARN>("bad option '-<ONAME>=<OVAL>', want range 0..100");
                }
                <OVAL>;
          }

OPTION:   maxident
usage:    "Only report sequences with percent identity <= N compared to reference"
type:     f
default:  100
param:
convert:  sub { <ARGS>;
                if (<OVAL> < 0 or <OVAL> > 100) {
                    <WARN>("bad option '-<ONAME>=<OVAL>', want range 0..100");
                }
                <OVAL>;
          }

###########################################################################
[FILTER]

text:     "General row/column filters:"

OPTION:   top
usage:    "Report top N hits"
type:     s
default:  all
param:    topn
convert:  sub { <ARGS>;
            return 0    if <OVAL> eq 'all';
            return <TEST>('i', <ONAME>, <OVAL>);
          }

OPTION:   show
usage:    "Keep rows 1..N or identifiers"
type:     @s
param:    keeplist

OPTION:   hide
usage:    "Hide rows 1..N or identifiers"
type:     @s
param:    skiplist

OPTION:   nops
usage:    "No operation: exclude rows 1..N or identifiers from calculatons"
type:     @s
param:    nopslist

OPTION:   range
usage:    "Display column range M:N as numbered by ruler"
type:     s
default:  all
param:
convert:  sub { <ARGS>;
            my @tmp = ();
            if (<OVAL> ne 'all') {
                @tmp = split(/:/, <OVAL>);
                if (@tmp != 2) {
                    <WARN>("bad range setting '-<ONAME>=<OVAL>', want M:N");
                } else {
                    <TEST>('i', <ONAME>, $tmp[0]);
                    <TEST>('i', <ONAME>, $tmp[1]);
                    #ignore range order, but check for negative values
                    if ($tmp[0] < 1 or $tmp[1] < 1) {
                        <WARN>("bad range setting '-<ONAME>=<OVAL>', want M:N");
                    }
                }
            }
            return [ @tmp ];
          }

###########################################################################
[MOLTYPE]

text:     "Molecule type:"

OPTION:   moltype
usage:    "Affects coloring and format converions <CHOOSE>(Bio::MView::Manager::check_molecule_type)"
type:     s
default:  aa
param:    moltype
convert:  sub { <ARGS>;
              if    (<OVAL> =~ /^aa/i)  { <PVAL> = 'aa';  }
              elsif (<OVAL> =~ /^na/i)  { <PVAL> = 'na';  }
              elsif (<OVAL> =~ /^dna/i) { <PVAL> = 'dna'; }
              elsif (<OVAL> =~ /^rna/i) { <PVAL> = 'rna'; }
              unless (defined <PVAL> and defined
                       Bio::MView::Manager::check_molecule_type(<PVAL>)) {
                   <WARN>("bad option '-<ONAME>=<OVAL>'");
                   <WARN>("known molecule types are: ", join(",",
                     Bio::MView::Manager::check_molecule_type));
              }
              (<PARAM>{'def_aln_colormap'},
               <PARAM>{'def_con_colormap'}) =
                   Bio::MView::Manager::get_default_colormaps(<PVAL>);
              <PARAM>{'def_aln_groupmap'} = <PARAM>{'def_con_groupmap'} =
                 Bio::MView::Manager::get_default_groupmap(<OVAL>);
              <PARAM>{'moltype'} = <PVAL>;
              <PVAL>;
          }

###########################################################################
[ALN]

text:     "Alignment coloring:"

OPTION:   coloring
usage:    "Basic style of coloring <CHOOSE>(Bio::MView::Manager::check_alignment_color_scheme)"
type:     s
default:  none
param:    aln_coloring
convert:  sub { <ARGS>;
              if    (<OVAL> =~ /^n/i) { <PVAL> = 'none';      }
              elsif (<OVAL> =~ /^a/i) { <PVAL> = 'any';       }
              elsif (<OVAL> =~ /^i/i) { <PVAL> = 'identity';  }
              elsif (<OVAL> =~ /^m/i) { <PVAL> = 'mismatch';  }
              elsif (<OVAL> =~ /^c/i) { <PVAL> = 'consensus'; }
              elsif (<OVAL> =~ /^g/i) { <PVAL> = 'group';     }
              unless (defined <PVAL> and defined
                       Bio::MView::Manager::check_alignment_color_scheme(<PVAL>)) {
                   <WARN>("bad option '-<ONAME>=<OVAL>'");
                   <WARN>("known color schemes are: ", join(",",
                   Bio::MView::Manager::check_alignment_color_scheme));
              }
              <PVAL>;
          }

OPTION:   colormap
usage:    "Name of colormap to use"
type:     s
param:    aln_colormap
convert:  sub { <ARGS>;
              if (defined <OVAL>) { <PVAL> = <OVAL>; }
              else                { <PVAL> = <PARAM>{'def_aln_colormap'}; }
              <PVAL> = Bio::MView::Manager::check_colormap(<PVAL>);
              unless (defined <PVAL>) {
                  <WARN>("bad option '-<ONAME>=<OVAL>'");
                  <WARN>("known colormaps are: ", join(",",
                         Bio::MView::Manager::check_colormap));
              }
              <DELETE_PARAM>('def_aln_colormap');
              <PVAL>;
          }

OPTION:   groupmap
usage:    "Name of groupmap to use if coloring by consensus"
type:     s
param:    aln_groupmap
convert:  sub { <ARGS>;
              if (defined <OVAL>) { <PVAL> = <OVAL>; }
              else                { <PVAL> = <PARAM>{'def_aln_groupmap'}; }
              <PVAL> = Bio::MView::Manager::check_groupmap(<PVAL>);
              unless (defined <PVAL>) {
                  <WARN>("bad option '-<ONAME>=<OVAL>'");
                  <WARN>("known group maps are: ", join(",",
                         Bio::MView::Manager::check_groupmap));
              }
              <DELETE_PARAM>('def_aln_groupmap');
              <PVAL>;
          }

OPTION:   threshold
usage:    "Threshold percentage for consensus coloring"
type:     f
default:  70
param:    aln_threshold
convert:  sub { <ARGS>;
              if (<OVAL> < 50 or <OVAL> > 100) {
                  <WARN>("bad value for '-<ONAME>=<OVAL>' must be in range 50..100");
              }
              [ <OVAL> ];
          }

OPTION:   ignore
usage:    "Ignore singleton or class groups <CHOOSE>(Bio::MView::Manager::check_ignore_class)"
type:     s
default:  none
param:    aln_ignore
convert:  sub { <ARGS>;
            <PVAL> = Bio::MView::Manager::check_ignore_class(<OVAL>);
            if (!defined <PVAL>) {
              <WARN>("bad option '-<ONAME>=<OVAL>'");
              <WARN>("known ignore classes are: ", join(",",
                     Bio::MView::Manager::check_ignore_class));
            }
            <PVAL>;
          }

###########################################################################
[CON]

text:     "Consensus coloring:"

OPTION:   con_coloring
usage:    "Basic style of coloring <CHOOSE>(Bio::MView::Manager::check_consensus_color_scheme)"
type:     s
default:  none
param:    con_coloring
convert:  sub { <ARGS>;
               if    (<OVAL> =~ /^n/i) { <PVAL> = 'none';     }
               elsif (<OVAL> =~ /^a/i) { <PVAL> = 'any';      }
               elsif (<OVAL> =~ /^i/i) { <PVAL> = 'identity'; }
               unless (defined <PVAL> and defined
                       Bio::MView::Manager::check_consensus_color_scheme(<PVAL>)) {
                  <WARN>("known color schemes are: ", join(",",
                         Bio::MView::Manager::check_consensus_color_scheme));
               }
               <PVAL>;
          }

OPTION:   con_colormap
usage:    "Name of colormap to use"
type:     s
param:    con_colormap
convert:  sub { <ARGS>;
              if (defined <OVAL>) {
                  <PVAL> = <OVAL>;
              } else {
                  <PVAL> = <PARAM>{'def_con_colormap'};
              }
              <PVAL> = <PARAM>{'def_con_colormap'} unless defined <OVAL>;
              <PVAL> = Bio::MView::Manager::check_colormap(<PVAL>);
              unless (defined <PVAL>) {
                  <WARN>("bad option '-<ONAME>=<OVAL>'");
                  <WARN>("known consensus colomaps are: ", join(",",
                         Bio::MView::Manager::check_colormap));
              }
              <DELETE_PARAM>('def_con_colormap');
              <PVAL>;
          }

OPTION:   con_groupmap
usage:    "Name of groupmap to use if coloring by consensus"
type:     s
param:    con_groupmap
convert:  sub { <ARGS>;
              if (defined <OVAL>) {
                  <PVAL> = <OVAL>;
              } else {
                  <PVAL> = <PARAM>{'def_con_groupmap'};
              }
              <PVAL> = Bio::MView::Manager::check_groupmap(<PVAL>);
              unless (defined <PVAL>) {
                  <WARN>("bad option '-<ONAME>=<OVAL>'");
                  <WARN>("known consensus group maps are: ", join(",",
                         Bio::MView::Manager::check_groupmap));
              }
              <DELETE_PARAM>('def_con_groupmap');
              <PVAL>;
          }

OPTION:   con_threshold
usage:    "Consensus line thresholds"
type:     @f
default:  '100,90,80,70'
param:    con_threshold
convert:  sub { <ARGS>;
              local $_;
              foreach (@{<PVAL>}) {
                if ($_ < 50 or $_ > 100) {
                  <WARN>("bad range for '-<ONAME>=$_' must be in range 50..100");
                }
              }
              <PVAL>;
          }

OPTION:   con_ignore
usage:    "Ignore singleton or class groups <CHOOSE>(Bio::MView::Manager::check_ignore_class)"
type:     s
default:  none
param:    con_ignore
convert:  sub { <ARGS>;
            <PVAL> = Bio::MView::Manager::check_ignore_class(<OVAL>);
            if (!defined <PVAL>) {
              <WARN>("bad option '-<ONAME>=<OVAL>'");
              <WARN>("known consensus ignore classes are: ", join(",",
                     Bio::MView::Manager::check_ignore_class));
            }
            <PVAL>;
          }

OPTION:   con_gaps
usage:    "Count gaps during consensus computations if set to 'on'"
type:     b
default:  on
param:

###########################################################################
[PATTERNS]

text:     "Motif colouring:"

OPTION:   find
usage:    "Find and highlight exact string or simple regular expression or ':' delimited set of patterns"
type:     s
default:  ""
param:
action:   sub { <ARGS>;
                if (<OVAL>) {
                    <PARAM>{'fnd_colormap'} =
                        Bio::MView::Manager::get_default_find_colormap();
                }
          }

###########################################################################
[GENERALFORMAT]

text:     "Miscellaneous formatting:"

OPTION:   label0
usage:    "Switch off label {0= row number}"
default:  0
param:
convert:  sub { <ARGS>; (<OVAL> ? 0 : 1) }

OPTION:   label1
usage:    "Switch off label {1= identifier}"
default:  0
param:
convert:  sub { <ARGS>; (<OVAL> ? 0 : 1) }

OPTION:   label2
usage:    "Switch off label {2= description}"
default:  0
param:
convert:  sub { <ARGS>; (<OVAL> ? 0 : 1) }

OPTION:   label3
usage:    "Switch off label {3= scores}"
default:  0
param:
convert:  sub { <ARGS>; (<OVAL> ? 0 : 1) }

OPTION:   label4
usage:    "Switch off label {4= percent coverage}"
default:  0
param:
convert:  sub { <ARGS>; (<OVAL> ? 0 : 1) }

OPTION:   label5
usage:    "Switch off label {5= percent identity}"
default:  0
param:
convert:  sub { <ARGS>; (<OVAL> ? 0 : 1) }

OPTION:   label6
usage:    "Switch off label {6= first sequence positions: query}"
default:  0
param:
convert:  sub { <ARGS>; (<OVAL> ? 0 : 1) }

OPTION:   label7
usage:    "Switch off label {7= second sequence positions: hit}"
default:  0
param:
convert:  sub { <ARGS>; (<OVAL> ? 0 : 1) }

OPTION:   gap
usage:    "Use this gap character"
type:     s
default:  -
param:

OPTION:   register
usage:    "Output multi-pass alignments with columns in register"
type:     b
default:  on
param:

###########################################################################
[HTML]

text:     "HTML markup:"

OPTION:   html
usage:    "Controls amount of HTML markup {head,body,data,full,off}"
type:     s
default:  off
param:
convert:  sub { <ARGS>;
                if (<OVAL> =~ /^full/i) { <OPTION>{<ONAME>} = (16|8|4|2|1); return 1; }
                if (<OVAL> =~ /^head/i) { <OPTION>{<ONAME>} = (8|4|2|1); return 1; }
                if (<OVAL> =~ /^body/i) { <OPTION>{<ONAME>} = (4|2|1); return 1; }
                if (<OVAL> =~ /^data/i) { <OPTION>{<ONAME>} = (1); return 1; }
                if (<OVAL> =~ /^off/i)  { <OPTION>{<ONAME>} = 0; return 0; }
                <WARN> ("bad option '-<ONAME>=<OVAL>'");
            }

OPTION:   bold
usage:    "Use bold emphasis for coloring sequence symbols"
default:  0
param:
convert:  sub { <ARGS>; <OVAL> > 0 ? 1 : 0 }

OPTION:   css
usage:    "Use Cascading Style Sheets {off,on,URL}"
type:     s
default:  off
param:    css1
convert:  sub { <ARGS>;
                #supplied style sheet URL
                return 1  if <OVAL> =~ /^(?:file|http):/i;
                if (<OVAL> ne 'on' and <OVAL> ne 'off' and <OVAL> ne '0' and <OVAL> ne '1') {
                    <WARN>("bad value for '-<ONAME>=<OVAL>' want {on,off,URL} or {0,1,URL}");
                }
                return 1  if <OVAL> eq 'on' or <OVAL> eq '1';
                return 0;
          }

OPTION:   title
usage:    "Page title string"
type:     s
default:  ""

OPTION:   pagecolor
usage:    "Page backgound color"
type:     s
default:  white

OPTION:   textcolor
usage:    "Page text color"
type:     s
default:  black

OPTION:   alncolor
usage:    "Alignment background color"
type:     s
default:  white
param:

OPTION:   labcolor
usage:    "Alignment label color"
type:     s
default:  black
param:

OPTION:   symcolor
usage:    "Alignment symbol default color"
type:     s
default:  #666666
param:

OPTION:   gapcolor
usage:    "Alignment gap color"
type:     s
default:  #666666
param:

###########################################################################
[SRSLINKS]

text:     "Database links:"

OPTION:   srs
usage:    "Try to use sequence database links {off,on}"
type:     s
default:  off
action:   sub { <ARGS>;
                if    (<OVAL> eq 'off') { return $Bio::SRS::Type = 0; }
                elsif (<OVAL> eq 'on')  { return $Bio::SRS::Type = 1; }
                else {
                    <WARN>("bad SRS setting, want {off,on}");
                }
                return $Bio::SRS::Type = 1;    #default
            }

OPTION:   linkcolor
usage:    "Link color"
type:     s
default:  blue
param:

OPTION:   alinkcolor
usage:    "Active link color"
type:     s
default:  red
param:

OPTION:   vlinkcolor
usage:    "Visited link color"
type:     s
default:  purple
param:

###########################################################################
[GENERICBLAST]

OPTION:   hsp
type:     s
default:  ranked
param:
convert:  sub { <ARGS>;
                return 'all'       if <OVAL> =~ /^a/;
                return 'discrete'  if <OVAL> =~ /^d/;
                return 'ranked'    if <OVAL> =~ /^r/;
                <WARN>("bad option '-<ONAME>=<OVAL>'");
                <WARN>("known hsp methods are: ", join(",",
                Bio::MView::Manager::check_hsp_tiling));
              }

OPTION:   maxeval
type:     s
default:  unlimited
param:
convert:  sub { <ARGS>;
                return undef    if <OVAL> eq 'unlimited';
                <TEST>('f', <ONAME>, <OVAL>);
                <WARN>("bad option '-<ONAME>=<OVAL>', want > 0") if <OVAL> < 0;
                <OVAL>;
          }

OPTION:   minbits
type:     s
default:  unlimited
param:
convert:  sub { <ARGS>;
                return undef    if <OVAL> eq 'unlimited';
                <TEST>('f', <ONAME>, <OVAL>);
                <WARN>("bad option '-<ONAME>=<OVAL>', want > 0") if <OVAL> < 0;
                <OVAL>;
          }

OPTION:   strand
type:     @s
default:  both
param:
convert:  sub { <ARGS>;
                local $_;
                foreach (@{<PVAL>}) {
                    if    (lc $_ eq 'p')    { return ['+']; }
                    elsif (lc $_ eq 'm')    { return ['-']; }
                    elsif (lc $_ eq 'both') { return [];    }
                    elsif ($_ eq '*')       { return [];    }
                    else {
                        <WARN>("bad value for '-<ONAME>=$_', choose from '{p,m,both,*}'");
                    }
                }
            }

OPTION:   keepinserts
type:     b
default:  off
param:

###########################################################################
[BLAST1]

text:     "NCBI BLAST (series 1), WashU-BLAST:"

#generic
OPTION:   hsp
usage:    "HSP tiling method <CHOOSE>(Bio::MView::Manager::check_hsp_tiling)"
type:     s
default:  ranked

OPTION:   maxpval
usage:    "Ignore hits with p-value greater than N"
type:     s
default:  unlimited
param:
convert:  sub { <ARGS>;
                return undef    if <OVAL> eq 'unlimited';
                <TEST>('f', <ONAME>, <OVAL>);
                <WARN>("bad option '-<ONAME>=<OVAL>', want > 0") if <OVAL> < 0;
                <OVAL>;
          }

OPTION:   minscore
usage:    "Ignore hits with score less than N"
type:     s
default:  unlimited
param:
convert:  sub { <ARGS>;
                return undef    if <OVAL> eq 'unlimited';
                <TEST>('f', <ONAME>, <OVAL>);
                <WARN>("bad option '-<ONAME>=<OVAL>', want > 0") if <OVAL> < 0;
                <OVAL>;
          }

#generic
OPTION:   strand
usage:    "Report only these query strand orientations {p,m,both,*}"
type:     @s
default:  both

#generic
OPTION:   keepinserts
usage:    "Keep hit sequence insertions in unaligned output"
type:     b
default:  off
param:

###########################################################################
[BLAST2]

text:     "NCBI BLAST (series 2), BLAST+:"

#generic
OPTION:   hsp
usage:    "HSP tiling method <CHOOSE>(Bio::MView::Manager::check_hsp_tiling)"
type:     s
default:  ranked

#generic
OPTION:   maxeval
usage:    "Ignore hits with e-value greater than N"
type:     s
default:  unlimited

#generic
OPTION:   minbits
usage:    "Ignore hits with bits less than N"
type:     s
default:  unlimited

#generic
OPTION:   strand
usage:    "Report only these query strand orientations {p,m,both,*}"
type:     @s
default:  both

#generic
OPTION:   keepinserts
usage:    "Keep hit sequence insertions in unaligned output"
type:     b
default:  off
param:

###########################################################################
[PSIBLAST]

text:     "NCBI PSI-BLAST:"

#generic
OPTION:   hsp
usage:    "HSP tiling method <CHOOSE>(Bio::MView::Manager::check_hsp_tiling)"
type:     s
default:  ranked

#generic
OPTION:   maxeval
usage:    "Ignore hits with e-value greater than N"
type:     s
default:  unlimited

#generic
OPTION:   minbits
usage:    "Ignore hits with bits less than N"
type:     s
default:  unlimited

OPTION:   cycle
usage:    "Process the N'th cycle of a multipass search {1..N,first,last,all,*}"
type:     @s
default:  last
param:
convert:  sub { <ARGS>;
                local $_; my @tmp=();
                foreach (@{<PVAL>}) {
                    if    ($_ eq 'first') { push @tmp, 1;    }
                    elsif ($_ eq 'last')  { push @tmp, 0;    }
                    elsif ($_ eq 'all')   { @tmp = (); last; }
                    elsif ($_ eq '*')     { @tmp = (); last; }
                    elsif (/^\d+$/)       { push @tmp, $_;   }
                    else {
                        <WARN>("bad value for '-<ONAME>=$_', choose from '{1..N,first,last,all,*}'");
                    }
                }
                return [ @tmp ];
            }

#generic
OPTION:   keepinserts
usage:    "Keep hit sequence insertions in unaligned output"
type:     b
default:  off
param:

###########################################################################
[FASTA]

text:     "FASTA (U. of Virginia):"

OPTION:   minopt
usage:    "Ignore hits with opt score less than N"
type:     s
default:  unlimited
param:
convert:  sub { <ARGS>;
                return undef    if <OVAL> eq 'unlimited';
                <TEST>('f', <ONAME>, <OVAL>);
                <WARN>("bad option '-<ONAME>=<OVAL>', want > 0") if <OVAL> < 0;
                <OVAL>;
          }

#generic
OPTION:   strand
usage:    "Report only these query strand orientations {p,m,both,*}"
type:     @s
default:  both

###########################################################################
[HSSP]

text:     "HSSP/Maxhom:"

OPTION:   chain
usage:    "Report only these chainnames/numbers {A..B,1..N,first,last,all,*}"
type:     @s
default:  *
param:
convert:  sub { <ARGS>;
                local $_; my @tmp=();
                foreach (@{<PVAL>}) {
                    if    ($_ eq 'first') { push @tmp, 1;    }
                    elsif ($_ eq 'last')  { push @tmp, 0;    }
                    elsif ($_ eq 'all')   { @tmp = (); last; }
                    elsif ($_ eq '*')     { @tmp = (); last; }
                    else                  { push @tmp, $_;   }
                }
                return [ @tmp ];
            }

###########################################################################
[MAF]

text:     "UCSC MAF:"

OPTION:   block
usage:    "Report only these blocks {1..N,first,last,all,*}"
type:     @s
default:  first
param:
convert:  sub { <ARGS>;
                local $_; my @tmp=();
                foreach (@{<PVAL>}) {
                    if    ($_ eq 'first') { push @tmp, 1;    }
                    elsif ($_ eq 'last')  { push @tmp, 0;    }
                    elsif ($_ eq 'all')   { @tmp = (); last; }
                    elsif ($_ eq '*')     { @tmp = (); last; }
                    elsif (/^\d+$/)       { push @tmp, $_;   }
                    else {
                        <WARN>("bad value for '-<ONAME>=$_', choose from '{1..N,first,last,all,*}'");
                    }
                }
                return [ @tmp ];
            }

###########################################################################
[MULTAL]

text:     "MULTAL/MULTAS:"

#share
OPTION:   block
usage:    "Report only these blocks {1..N,first,last,all,*}"
type:     @s
default:  first

###########################################################################
[MAPS]

text:     "User defined colormap and consensus group definition:"

OPTION:   colorfile
usage:    "Load more colormaps from file"

OPTION:   groupfile
usage:    "Load more groupmaps from file"

###########################################################################
[HELP]

text:     "More information and help:"

OPTION:   help
usage:    "This help"

OPTION:   listcolors
usage:    "Print listing of known colormaps"

OPTION:   listgroups
usage:    "Print listing of known consensus groups"

OPTION:   listcss
usage:    "Print style sheet"

###########################################################################
